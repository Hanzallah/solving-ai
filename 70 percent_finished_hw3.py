# -*- coding: utf-8 -*-
"""75% finished -- HW3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_n3kw5ozMvO62aNw4qXwiRFyFBlW1cVM
"""

# THINGS LEFT: Singlestepping statements, input formating.
# will do that tomorrow - 16/11/2020  
# But do please create few trees with different inputs (negative and postive integers)
# solve them and then try them out here. 
# IMP case: when two nodes are same but choice is done lexicographically 

#singleStepFlag = False ;

## notes :::  
# A = input("Enter Integer Values For A, B, C, D, E, F, G, H, I, separated by blank spaces: \n ")
#    By taking that one-time input and making it into a list - Leafs -  , we create the new tree

# Single stepping -- depends what he means, I emailed him and awaiting response 

# First part is using min and max , straighforward to apply minimaxing
# I used this to make sure my answer for the second and thrird trees in second program are correct

Leafs  = [5 ,3 , 1 , 2, 5 , 4 ,1, 3 , 3 ]
#Leafs   = [5 ,2 , 2 , 5, 1 , 3 ,2, 4 , 2 ]
#Leafs  = [1 ,3 , 4 , 1, 4 , 1 ,3, 5 , 3 ] 

L = min(Leafs[0],Leafs[1],Leafs[2])
M = min(Leafs[3],Leafs[4],Leafs[5])
R = min(Leafs[6],Leafs[ 7],Leafs[8])

Minimizer = [L, M, R]
sortedIndex = sorted(range(len(Minimizer)), key=lambda k: Minimizer[k], reverse = True)
Minimizer_dict = {0: "L"  ,1: "M"  , 2: "R" }

if Minimizer[sortedIndex[0]] == Minimizer[sortedIndex[1]] or Minimizer[sortedIndex[0]] == Minimizer[sortedIndex[1]] == Minimizer[sortedIndex[2]]:
  max = Minimizer_dict[sortedIndex[0]]
else:
  max = Minimizer_dict[sortedIndex[0]]
# >>> I realized the if else statement here is the same  which is weird, probably sleep deprivation two days ago, test it, and I will look at it better tomorrow. << log:15-11
# I need to get max and if two nodes have same value choose the earlier (from left, or lexicgrapgically using ascii order, ord())

print("The move of the max player is :", max )

# ------------------------ 2nd Program, Alpha-Beta----
# I used colab to write these so, run these programs in different blocks 
# 



Leafs  = [5 ,3 , 1 , 2, 5 , 4 ,1, 3 , 3 ]
#Leafs   = [5 ,2 , 2 , 5, 1 , 3 ,2, 4 , 2 ]
#Leafs  = [1 ,3 , 4 , 1, 4 , 1 ,3, 5 , 3 ]

Minimizer_dict = {0: "L"  ,1: "M"  , 2: "R" }
A=Leafs[0] 
B=Leafs[1] 
C=Leafs[2]
D=Leafs[3]
E=Leafs[4]
F=Leafs[5] 
G=Leafs[6] 
H=Leafs[7]
I=Leafs[8]  

pruned = []  

L = min(A,B,C)
M_ceil = D
R_ceil = G

if L >= M_ceil:
  #prune nodes, >> append to list of pruned nodes, E and F here -- in alphab. order
  pruned.append('E')
  pruned.append('F')

elif L < M_ceil:
  if M_ceil > E:
        M_ceil = E

  if L >= M_ceil:
       #prune F
        pruned.append('F')

  elif  M_ceil > F:
      M_ceil = F  
             #-------------- Now thrid , R node 
if L >= R_ceil or M_ceil >= R_ceil :
    # prune H I 
    pruned.append('H')
    pruned.append('I')
elif H < R_ceil:
        R_ceil = H
elif L >= R_ceil or M_ceil >= R_ceil :
    #prune I
        pruned.append('I')
elif I < R_ceil:
            R_ceil = I
else :
        pass

MaxinmizerLevel = [L ,M_ceil, R_ceil]
sortedIndex = sorted(range(len(MaxinmizerLevel)), key=lambda k: MaxinmizerLevel[k], reverse = True)

if MaxinmizerLevel[sortedIndex[0]] == MaxinmizerLevel[sortedIndex[1]] or MaxinmizerLevel[sortedIndex[0]] == MaxinmizerLevel[sortedIndex[1]] == MaxinmizerLevel[sortedIndex[2]]:
  max = Minimizer_dict[sortedIndex[0]]
else:
  max = Minimizer_dict[sortedIndex[0]]

# I need to get max and if two nodes have same value choose the earlier (from left, or lexicgrapgically using ascii order, ord())

print("The move of the max player is :", max )


print("The Pruned Nodes are :",pruned)
      
     
# remaining ,,, take the node name, as in A or B etc, and append it to a list for pruned nodes -- done! 
#
